// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
<<<
[[Core]]
== Tamaya Core
=== Overview

Tamaya Core provides an implementation of the Tamaya Configuration API and adds additional functionality and
building blocks for supporting SPI implementations.

Tamaya Core contains the following artifacts:

* Implementations of +Configuration, ConfigurationContext, ConfigurationContextBuilder+ ConfigurationProvider+
* A +ServiceLoader+ based +ServiceContext+ implementation.
* A PropertyConverterManager+ that loads and stores references to all the rconfigured +PropertyConverter+ instances.
* Default PropertySources for environment data.

All minimally required components are implemented and registered, so basically the RI is a complete configuration
solution. Nevertheless it is also very minimalistic:

. It collects all +PropertySource+ and +PropertySourceProvider+ instances registered with the +ServiceLoader+ and
  registers them in the global +ConfigurationContext+
. It provides a +ConfigurationContextBuilder+ and allows changing the current +ConfigurationContext+.
. It provides +PropertyConverter+ instances for the most commonly used types.
. It implements component priorization based on the +@Priority+ annotations.
. It provides default +PropertySources+ for
  .. Environment Properties
  .. System Properties
  .. a PropertySource based on a simple +Map<String,String>+.

[[CorePropertyConverters]]
=== Default PropertyConverters in Core

As said the _Core_ module delivers several default +PropertyConverter+ instances out of the box:

[width="100%",frame="1",options="header"]
|=======
|_Target Type_             |_Class Name_              |_Supported Formats_

|java.math.BigDecimal    |BigDecimalConverter     |1.2345, 0xFF
|java.math.BigInteger    |BigIntegerConverter     |0xFF, 1234
|java.lang.Boolean       |BooleanConverter        |true, false, T, F, 1 ,0
|java.lang.Byte          |ByteConverter           |0xFF, MIN_VALUE, MAX_VALUE, 123
|java.lang.Character     |CharConverter           |0xFF, 'a', 'H', 123
|java.lang.Class         |ClassConverter          |<fully qualified class name>
|java.util.Currency      |CurrencyConverter       |CHF, 123
|java.lang.Double        |DoubleConverter         |1, 0xFF, 1.2334, NaN, NEGATIVE_INFITIY, POSITIVE_INFINITY, MIN_VALUE, MAX_VALUE
|_Enums_                 |EnumConverter           |<Enum item name>
|java.lang.Float         |FloatConverter          |1, 0xFF, 1.2334, NaN, NEGATIVE_INFITIY, POSITIVE_INFINITY, MIN_VALUE, MAX_VALUE
|java.lang.Integer       |IntegerConverter        |1, 0xD3, MIN_VALUE, MAX_VALUE
|LocalDate               |LocalDateConverter      |<Date as defined by LocalDate.parse(String)
|LocalTime               |LocalTimeConverter      |<Time as defined by LocalTime.parse(String)
|LocalDateTime           |LocalDateTimeConverter  |<LocalDateTime as defined by LocalDateTime.parse(String)>
|java.lang.Long          |LongConverter           |1, 0xD3, MIN_VALUE, MAX_VALUE
|java.lang.Number        |NumberConverter         |1, 0xFF, 1.2334, NaN, NEGATIVE_INFITIY, POSITIVE_INFINITY
|java.lang.Short         |ShortConverter          |1, 0xD3, MIN_VALUE, MAX_VALUE
|java.net.URI            |URIConverter            |http://localhost:2020/testresource?api=true
|java.net.URL            |URLConverter            |http://localhost:2020/testresource?api=true
|ZoneId                  |ZoneIdConverter         |Europe/Zurich
|=======


=== Registering PropertyConverters

Additional +PropertyConverters+ can be implemented easily. It is recommended to register then using the +ServiceLoader+,
menaing you add a file under +META-INF/service/org.apache.tamaya.spi.PropertyConverter+ containing the fully qualified
class names of the converters to be registered (one line per each).

Alternatively you can also use a +ConfigurationContextBuilder+ to add additional converters programmatically, Note
hereby that implementations can be read-only thus not allowing adding additional converters programmatically.


[[ComponentPriorization]]
=== Component Loading and Priorization

Tamaya Core in general loads all components using the +ServiceLoader+ mechanism. This means that new components
must be registered by adding a file under +META-INF/service/<myInterfaceName>+ containing the fully qualified
implementation class names of the components to be registered (one line per each).
The +ServiceLoader+ itself does not provide any functionality for overriding or ordering of components. Tamaya
core adds this functionality by the possibility to add +@Priority+ annotations to the components registered.
By default, and if no annotation is added +0+ is used as priority. Hereby higher values preceed lower values, meaning

* if a singleton component is accessed from the current +ServiceContext+ the component with the higher value
  effectively _overrides/replaces_ any component with lower values.
* if a collection of components is obtained from the +ServiceContext+ the components are ordered in order, where the
  ones with higher priority are before components with lower priority.
* if priorities match Tamaya Core additionally sorts them using the simple class name. This ensures that ordering is
  still defined and predictable in almost all scenarios.


[[RegisteringPropertySources]]
=== Registering Property Sources

PropertySources that provide configuration properties are registered as ordinary components as described in the previous
section. Nevertheless the priority is not managed based on +@Priority+ annotations, but based on an explicit
+int getOrdinal()+ method. This allows to define the ordinal/priority of a +PropertySource+ explicitly. This is useful
due to several reasons:

* it allows to define the ordinal as part of the configuration, thus allowing new overriding property sources being
  added easily.
* it allows to define the ordinal dynamically, e.g. based on the configuration location, the time of loading or
  whatever may be appropriate.




== SPI
